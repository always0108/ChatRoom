####多进程与多线程
多进程，每个进程都有自己独立的地址空间;多线程，同一进程内的线程共享进程的地址空间。所以创建一个就要耗费时间来为其分配系统资源，而创建一个新线程花费的时间会少很多。

进程地址空间独立而线程共享地址空间，线程的切换速度远快于进程的切换速度

进程间数据空间相对独立，彼此间通信要以专门的通信方式进行，通信时必须经过操作系统。而同一进程内的多个线程共享数据空间，一个线程的数据可以直接提供给其他线程使用。进程间通信更加方便和省时。

#####综上，线程节约时间和资源

此外，线程可以提高程序的响应速度，可以提高多处理器的效率，可以改善程序的结构

ps：编写linux下的多线程应用程序，需要头文件pthread.h，链接时需要使用库libpthread.a

gcc ×××.c -lpthread
####线程的创建
pthread_create
```
#include<pthread.h>
int pthread_create(pthread_t *thread,pthread_attr_t * attr,
				void* (*start_routine)(void *),void *arg);
pthread_t pthread_self(void) //获取本线程的ID
int pthread_equal(pthread_t thread1，pthread_t thread2).//判断两个线程ID是否指向同一线程
int pthread_once(pthread_once_t *once_control,void(* init_routine)(void)) //用来保证init_routine线程函数在进程中仅执行一次
```
pthread_create

thread：一个指针，线程创建成功时，用来返回创建线程的ID
attr：该参数用于指定线程属性，NULL表示默认属性，可以了解，需要用再查
start_routine:一个函数指针，指向线程创建后要调用的函数;这个被线程调用的函数也叫做线程函数。
arg：该函数指向传递给函数的参数
注意：创建成功，函数返回0;若不为0则说明创建线程失败。


####线程的终止
1.通过return从线程函数返回
2.调用函数pthread_exit()使线程退出
3.调用pthread_cancel函数取消线程

在主线程中，如果从main函数返回或是调用exit函数退出主线程，则整个进程将终止，则**整个进程终止**，进程内的其他线程也会终止。若调用pthread_exit()函数，则**仅仅是主线进程消亡**，进程不会结束，其它线程也不会终止，直到所有线程结束，进程才会结束。

当进程要使用临界资源时，要提出请求，如果该资源未被使用则申请成功，否则等待。临界资源使用完毕后要释放以便其它线程使用。

临界资源为一个线程独占，当一个线程终止时，如果不释放其占有的临界资源，则该资源会被认为还被已经退出的线程所使用，因而永远不会得到释放，如果一个线程在等待使用这个临界资源，有可能无限制的等待，就形成来死锁。

利用pthread_cleanup_push(),pthread_cleanup_pop()函数可以自动释放资源

从pthread_cleanup_push()的调用点到pthread_cleanup_pop()之间的程序段中的终止动作（包括调用 pthread_exit()和取消点终止）都将执行pthread_cleanup_push()所指定的清理函数。

采用先入后出的栈结构管理，void routine(void *arg)函数在调用pthread_cleanup_push()时压入清理函数栈，多次对pthread_cleanup_push()的调用将在清理函数栈中形成一个函数链，在执行该函数链时按照压栈的相反顺序弹出。execute参数表示执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数，为0表示不执行，非0为执行；这个参数并不影响异常终止时清理函数的执行。
```
#include<pthread.h>
#define pthread_cleanup_push(routine,arg) \
{
	struct _pthread_cleanup_buffer buffer; \
		   _pthread_cleanup_push(&buffer,(routine),(srg))\
#define pthread_clean_pop \
	    _pthread_cleanup_pop(&buffer,(exeute));
}

pthread_cleanup_push((void *)pthread_mutex_unlock, (void *) &mut);
pthread_mutex_lock(&mut);
/* do some work */
pthread_mutex_unlock(&mut);
pthread_cleanup_pop(0);
```
本来do some work之后是有pthread_mutex_unlock(&mut);这句,也就是有解锁操作,但是在do some work时会出现非正常终止,那样的话,系统会根据pthread_cleanup_push中提供的函数,和参数进行解锁操作或者其他操作,以免造成死锁!

**attention:**pthread_cleanup_push()有'{',pthread_cleanup_pop()中有'}'，所以这两个函数要成对出现

一般情况下，进程中各个线程的运行是独立的，**线程的终止不会相互通知，也不会影响其他线程**，终止进程的所占有的资源不会随着线程的终止归还系统，仍为线程所在的进程拥有。

```
#include<pthread.h>
void pthread_exit(void * retval)
int pthread_join(pthread_t th,void * thread_return);
int pthread_detach(pthread_t th);
```
pthread_join()的调用者被挂起并等待th线程终止，如果thread_return不为NULL，则 *thread_return=retval，一个线程仅允许一个线程使用pthread_join等待它终止，并且被等待的进程应该处于可join状态，即非DETACHED。（如果有多个进程等待，第一个接受信号的成功返回，其余返回错误代码ESRCH）

一个可join的线程所占的内存仅当有线程对它执行pthread_join()后才会释放，
所以为了避免内存泄漏，所有线程终止时，要嘛已被设定为DETACHED，要嘛使用pthread_join()来回收资源。

#####pthread_cancel：来自其他线程的一个请求

但是如果子线程在某个操作被阻塞，等待它的线程会无限制的等待，形成死锁。为了更安全地使线程退出，主线程通过pthread_cancel函数来请求取消同一进程中的其他线程，再调用pthread_join等待指定线程退出。

注：当主线程调用pthread_cancel后，**只是将取消请求发送给指定线程， 成功调用不能保证指定线程已经退出**，需要调用pthread_join等待指定线程完全退出，再进行相关资源的释放。

**可取消状态**：当线程处于PTHREAD_CANCEL_ENABLE，收到cancel请求会使该线程退出运行；反之，若处于PTHREAD_CANCEL_DISABLE，收到的cancel请求将处于未决状态，线程不会退出。线程默认可取消状态为PTHREAD_CANCEL_ENABLE，可通过pthread_setcanceltype修改可取消类型。

**可取消类型**：当处于PTHREAD_CANCEL_DEFERRED，线程在收到cancel请求后，需要运行到取消点才能退出运行；如果处于PTHREAD_CANCEL_ASYNCHRONOUS，可以在任意时间取消，只要收到cancel请求即可马上退出。线程启动时默认可取消类型为PTHREAD_CANCEL_DEFERRED，可通过pthread_setcanceltype修改可取消类型。

取消点：线程检查是否被取消并按照请求进行动作的一个位置。

一般来说，为了防止资源未被释放时，线程就已经退出。将获取临界资源-释放临界资源之间的代码块都设置成PTHREAD_CANCEL_DISABLE状态，其余的代码块都设置成PTHREAD_CANCEL_ENABLE状态，确保线程在安全的地方退出。如果在可以安全退出的代码块不存在取消点系统调用，可以调用pthread_testcancel函数自己添加取消点。

####线程中的私有数据
进程中内的所有线程共享进程的数据空间，因此全局变量为所有线程共有，在程序设计时有时需要保存线程自己的全局变量，这种变量仅在某个线程的内部有效。这时就要用到线程的私有数据（TSD），在线程内部，线程的私有数据可以被各个函数访问，但它对其它线程是屏蔽的。

在使用线程的私有数据时，首先要为每个线程创建一个相关联的键，一键多值，通过键来指代线程数据。
#####1、pthread_key_create:创建一个键
```
int pthread_key_create(pthread_key_t *key,void(*destr_function) (void*));
```
首先从linux的TSD池(Thread-specific Data)中分配一项，然后将其值赋给key供以后访问使用。接口的第一个参数是指向参数的指针，第二参数是函数指针，如果该指针不为空，那么在线程执行完毕退出时，已key指向的内容为入参调用destr_function(),释放分配的缓冲区以及其他数据。

key被创建之后，因为是全局变量，所以所有的线程都可以访问。各个线程可以根据需求往key中，填入不同的值，这就相当于提供了一个同名而值不同的全局变量，即一键多值。
一键多值依靠的一个结构体数组，即
```
static struct pthread_key_struct pthread_keys[PTHREAD_KEYS_MAX] ={{0,NULL}};
```

#####2、pthread_setspecific:为指定键值设置线程私有数据
```
int pthread_setspecific(pthread_key_t key, const void *pointer);
```
该函数将指针pointer的值(指针值而非其指向的内容)与key相关联，用pthread_setspecific为一个键指定新的线程数据时，线程必须释放原有的数据用以回收空间。
#####3、pthread_getspecific：从指定键读取线程的私有数据
```
void * pthread_getspecific(pthread_key_t key);
```
通过该函数得到与key相关联的数据
#####4、pthread_key_delete：删除一个键
```
void * pthread_getspecific(pthread_key_t key);
```
该函数用于删除一个键，功能仅仅是将该key在结构体数组pthread_keys对应的元素设置为“un_use”，与改key相关联的线程数据是不会被释放的，因此线程私有数据的释放必须在释放键之前完成。

####线程同步

#####互斥锁（不占内存）

互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。在同一时刻它通常只允许一个线程执行一个关键部分的代码。

#####初始化：
初始化互斥锁的两种方式：
```
//静态赋值法
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIAER;
//通过pthread_mutex_init函数初始化
int pthread_mutex_init(pthread_mutex_t *mutex,
					constt pthread_mutexattr_t *mutexatter);
mutexatter表示互斥锁的属性，NULL则使用默认属性
```
互斥锁的属性
* PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。

* PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。

* PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。

* PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。

#####加锁：
```
int pthread_mutex_lock(pthread_mutex_t *mutex);//阻塞申请互斥锁
int pthread_mutex_trylock(pthread_mutex_t *mutex);//非阻塞申请互斥锁
```
pthread_mutex_lock()加锁时，如果mutex已被锁住，当前尝试加锁的线程就会阻塞，直到互斥锁被其它线程释放。当pthread_mutex_lock()函数返回时，说明互斥锁已经被当前进程成功加锁。

pthread_mutex_trylock()加锁时，如果mutex已被锁住，它将立即返回，返回错误代码EBUSY，而不是阻塞等待

attention：不论哪种类型的锁，都不可能被两个线程同时得到，其中一个必须等待解锁。在同一进程的线程，如果加锁后没有解锁，则其他进程无法再获得该锁。

####解锁
```
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
解锁要满足的条件：
1、互斥锁要处于加锁状态
2、调用该函数的线程必须是给互斥锁加锁的线程
（解锁后如果有其它进程正在等待互斥锁，等待队列的第一个线程会获得该互斥锁）

#####清除
```
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```
释放锁的资源，清除锁要求锁当前处于开放状态。若锁处于锁定状态，函数返回EBUSY，该函数执行成功返回0。

互斥锁实例：打印机
```
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex; //互斥锁

// 打印机,一段时间内只能被一个用户使用，不能被多人同时使用
void printer(char *str)
{
    pthread_mutex_lock(&mutex); //上锁
    while(*str!='\0')
    {
        putchar(*str);
        fflush(stdout);
        str++;
        sleep(1);
    }
    printf("\n");
    pthread_mutex_unlock(&mutex); //解锁
}


void printer2(char *str)
{
    //pthread_mutex_lock(&mutex); //上锁
    while(*str!='\0')
    {
        putchar(*str);
        fflush(stdout);
        str++;
        sleep(1);
    }
    printf("\n");
    //pthread_mutex_unlock(&mutex); //解锁
}
// 线程一
void *thread_fun_1(void *arg)
{
    char *str = "hello";
    printer(str); //打印
}

// 线程二
void *thread_fun_2(void *arg)
{
    char *str = "world";
    printer(str);
    //printer2(str); //打印
}

int main(void)
{
    pthread_t tid1, tid2;

    pthread_mutex_init(&mutex, NULL); //初始化互斥锁

    // 创建 2 个线程
    pthread_create(&tid1, NULL, thread_fun_1, NULL);
    pthread_create(&tid2, NULL, thread_fun_2, NULL);

    // 等待线程结束，回收其资源
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    pthread_mutex_destroy(&mutex); //销毁互斥锁

    return 0;
}

/*
 * 上锁
[limeng@KID 8.1]$ gcc huchisuo.c  -lpthread
[limeng@KID 8.1]$ ./a.out 
hello
world
 *不上锁 
[limeng@KID 8.1]$ gcc huchisuo.c  -lpthread
[limeng@KID 8.1]$ ./a.out 
hweolrlldi
thread1上锁，thread2不上锁
[limeng@KID 8.1]$ ./a.out
hweolrllod
*/

//可见使用互斥锁就是为了让某一资源在一段时间内一个进程被独占，从而不混乱，但是一个线程对某一资源上锁，其它没有上锁的资源还可以对其操作。所以，互斥锁又叫建议锁，或者协同锁。但不是强制性的。

```

条件变量
1.一个等待使用资源的线程等待“条件变量被设置为真”
2.另一个线程在使用完资源后“设置条件为真”

#####初始化
```
//静态赋值法
pthread_cond_t cond=PTHREAD_COND_INITIALIER;
//使用init函数
int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr);  
```
cond_attr参数是条件变量的属性，由于其并没有得到实现，所以它的值通常为NULL

#####等待条件成立
```
int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);
int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);
```
pthread_cond_wait函数释放由mutex指向的互斥锁，同时当前进程关于cond指向的条件变量阻塞，直到条件信号被唤醒。

pthread_cond_timewait将阻塞直到条件变量获得信号或者经由abstime指定的时间。如果在指定时间结束都没有条件满足，则返回ETIMEOUT,结束等待。

#####解除阻塞
```
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond); 
```
pthread_cond_signal激活一个等待条件成立的线程，存在多个等待线程时，安入队顺序激活
pthread_cond_broadcast激活所有等待条件的线程

#####清除条件变量
```
int pthread_cond_destroy(pthread_cond_t *cond);
```
只有在没有线程等待该条件变量的时候才能清除这个条件变量，否则返回EBUSY
```
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;

void * thread1(void * arg)
{
    pthread_cleanup_push((void *)pthread_mutex_unlock,&mutex);
    while(1){
        printf("thread1 is running\n");
        pthread_mutex_lock(&mutex);
        pthread_cond_wait(&cond,&mutex);
        printf("thread1 applied the condition\n");
        pthread_mutex_unlock(&mutex);
        printf("unlock\n");
        printf("\n");
        sleep(1);
    }
    pthread_cleanup_pop(0);
}

void *thread2(void * arg)
{
    while(1){
        printf("thread2 is running\n");
        pthread_mutex_lock(&mutex);
        printf("thread2  get\n");
        pthread_cond_wait(&cond,&mutex);

        printf("thread2 applied the condition\n");
        
        pthread_mutex_unlock(&mutex);
        printf("unlock\n");
        printf("\n");
        sleep(1);
    }
}

int main(void)
{
    pthread_t tid1,tid2;

    printf("condition variable study!\n");
    pthread_mutex_init(&mutex,NULL);
    pthread_cond_init(&cond,NULL);
    pthread_create(&tid1,NULL,(void *)thread1,NULL);
    pthread_create(&tid2,NULL,(void *)thread2,NULL);

    do{
        sleep(2);
        pthread_cond_signal(&cond);
    }while(1);
    sleep(50);
    pthread_exit(0);
}


/*
pthread_cleanup_push((void *)pthread_mutex_unlock, (void *) &mut);
pthread_mutex_lock(&mut);
// do some work 
pthread_mutex_unlock(&mut);
pthread_cleanup_pop(0);
本来do some work之后是有pthread_mutex_unlock(&mut);这句,也就是有解锁操作,但是在do some work时会出现非正常终止,那样的话,系统会根据pthread_cleanup_push中提供的函数,和参数进行解锁操作或者其他操作,以免造成死锁!
*/

/*在这里是thread1先上锁，然后通过pthread_cond_wait使其阻塞，进入等待队列，释放锁;这时thread2开始上锁，接着也因为条件变量阻塞并释放锁，进入等待队列。这时主线程通过pthread_cond_signal激活一个等待条件成立的线程，这时thread1在等待队列的前面，所以thread1被激活，这时互斥锁重新被锁上，然后进行完之后，解锁。然后解锁，上锁，条件变量阻塞再次进入等待队列，接下来该激活thread2,以此类推（sleep先不考虑，大致就是这样）*/
```

####异步信号
信号与任何线程通信都是异步的。信号到达的时间是不定的。如果有多个线程接受信号，只有一个被选中。如果并发的多个信号被送到一个进程，每一个将被不同的线程处理。如果所有线程都屏蔽该信号，则这些信号被挂起，直到有信号解除屏蔽来处理它们。

```
//向特定的线程发送信号signo
int pthread_kill(pthread_t threadid,int signo);
//设置线程的信号屏蔽码
int pthread_sigmask(int how,const sigset_t *newmask,sigset_t *oldmask);
//阻塞线程
int sigwait(const sigset_t *set,int *sig);
```
关于信号，到信号那一章再仔细研究。



